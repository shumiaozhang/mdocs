import{_ as s,c as i,o as a,a2 as t}from"./chunks/framework.DwDoyBw8.js";const g=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"ts/类型系统/15. 类型的兼容.md","filePath":"ts/类型系统/15. 类型的兼容.md","lastUpdated":1712760158000}'),e={name:"ts/类型系统/15. 类型的兼容.md"},n=t(`<p>ts的类型存在兼容关系，某些类型可以兼容其他类型。</p><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">type</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> T</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> number</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">|</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">string</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">number</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> b</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">T</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a;</span></span></code></pre></div><p>变量<code>a</code>和<code>b</code>的类型是不一样的，但是变量<code>a</code>赋值给变量<code>b</code>并不会报错。这时，我们就认为，<code>b</code>的类型兼容<code>a</code>的类型。</p><p><strong>在ts中，如果类型A的值可以赋值给类型B，那么类型A就称为类型B的子类型，其中子类型可以赋值给父类型，父类型不能赋值给A类型。</strong></p><p>之所以有这样的规则，是因为<strong>子类型继承了父类型的所有特征</strong>，所以可以用在父类型的场合。但是，子类型可以有自己扩展的特征，就可能有父类型没有该特征，所以<strong>父类型不能用在子类型</strong>。</p>`,5),p=[n];function h(l,k,d,r,o,c){return a(),i("div",null,p)}const y=s(e,[["render",h]]);export{g as __pageData,y as default};
