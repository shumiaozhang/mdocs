import{_ as s,c as t,o as a,a2 as n}from"./chunks/framework.DwDoyBw8.js";const g=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"ts/类型断言/2. 类型断言的条件.md","filePath":"ts/类型断言/2. 类型断言的条件.md","lastUpdated":1712676697000}'),i={name:"ts/类型断言/2. 类型断言的条件.md"},e=n(`<p>类型断言并不能将某个值断言为任意类型，而是必须某种条件，就是<strong>指定类型是实际值的子类型或者实际值是指定类型的子类型</strong>才可以。</p><p>也就是说类型断言要求实际的类型与断言的类型兼容，实际类型可以断言为一个更加宽泛的类型父类型，也可以断言为一个更加精确的子类型，但不能断言为一个完全无关的类型。</p><p>如果真要断言成一个无关类型的，可以进行两次类型断言，先断言成any或unknown类型，再断言成目标类型，因为any、unknown类型是所有其他类型的父类型，可以作为两种完全无关类型的中介。</p><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 或者写成 &lt;T&gt;&lt;unknown&gt;expr</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">expr </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">as</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> unknown</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> as</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> T</span></span></code></pre></div>`,4),p=[e];function _(l,o,r,c,h,d){return a(),t("div",null,p)}const u=s(i,[["render",_]]);export{g as __pageData,u as default};
