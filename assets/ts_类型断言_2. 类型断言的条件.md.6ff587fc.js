import{_ as s,o as t,c as n,U as a}from"./chunks/framework.adbdbaa5.js";const u=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"ts/类型断言/2. 类型断言的条件.md","filePath":"ts/类型断言/2. 类型断言的条件.md"}'),e={name:"ts/类型断言/2. 类型断言的条件.md"},o=a(`<p>类型断言并不能将某个值断言为任意类型，而是必须某种条件，就是<strong>指定类型是实际值的子类型或者实际值是指定类型的子类型</strong>才可以。</p><p>也就是说类型断言要求实际的类型与断言的类型兼容，实际类型可以断言为一个更加宽泛的类型父类型，也可以断言为一个更加精确的子类型，但不能断言为一个完全无关的类型。</p><p>如果真要断言成一个无关类型的，可以进行两次类型断言，先断言成any或unknown类型，再断言成目标类型，因为any、unknown类型是所有其他类型的父类型，可以作为两种完全无关类型的中介。</p><div class="language-typescript"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#676E95;font-style:italic;">// 或者写成 &lt;T&gt;&lt;unknown&gt;expr</span></span>
<span class="line"><span style="color:#A6ACCD;">expr </span><span style="color:#89DDFF;font-style:italic;">as</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">unknown</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">as</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">T</span></span></code></pre></div>`,4),p=[o];function l(c,r,_,i,d,y){return t(),n("div",null,p)}const f=s(e,[["render",l]]);export{u as __pageData,f as default};
