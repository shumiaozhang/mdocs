import{_ as s,o as n,c as a,U as l}from"./chunks/framework.adbdbaa5.js";const i=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"ts/class类/4. 类的继承.md","filePath":"ts/class类/4. 类的继承.md","lastUpdated":1711942069000}'),p={name:"ts/class类/4. 类的继承.md"},o=l(`<p>类(子类)可以使用extends关键字继承另一个类(基类)的所有属性和方法</p><div class="language-typescript"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">class</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">A</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#F07178;">greet</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">Hello, world!</span><span style="color:#89DDFF;">&#39;</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C792EA;">class</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">B</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">extends</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">A</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> b </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">B</span><span style="color:#A6ACCD;">()</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">b</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">greet</span><span style="color:#A6ACCD;">() </span><span style="color:#676E95;font-style:italic;">// &quot;Hello, world!&quot;</span></span></code></pre></div><p>根据<strong>结构类型原则</strong>，子类也可以用在类型为基类的场合。</p><p>如果子类在继承时会覆盖基类的同名，两者的类型不能冲突。</p><p><code>extends</code>关键字后面不一定是类名，可以是一个表达式，只要它的类型是构造函数就可以了。</p><p>当编译设置的target大于2022时，对于那些子类只设置了类型、没有初值的顶层属性在基类中被赋值后，会被重置为undefined。解决方法：使用declare命令，去声明顶层成员的类型，告诉ts这些成员的赋值是由基类实现的。</p>`,6),e=[o];function t(c,r,y,D,F,A){return n(),a("div",null,e)}const _=s(p,[["render",t]]);export{i as __pageData,_ as default};
