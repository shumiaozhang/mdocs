一个模块就是一个独立的文件，这个文件中的所有变量，只能在文件内部使用，假如想在外部使用，则必须先导出，然后在使用的文件中进行导入
才能使用。

在讲ES6中的导入导出之前，需要我们知道的是之前JavaScript并没有真正意义的模块化。之前社区指定了一些模块化方案，分别是commonJS和AMD两种，
而ES6引入的导入与导出完全可以替代之前的。

## 1. 设计思想 - 静态化

这样的好处就是在编译的时候就能确定模块的依赖关系，而不是等到运行的时候。commonJS和AMD就是运行的时候
才能知道那些会用到那些不会被用到，这样效率会变低。

```js
// CommonJS模块
let { stat, exists, readfile } = require('fs');

// 等同于
let _fs = require('fs');
let stat = _fs.stat;
let exists = _fs.exists;
let readfile = _fs.readfile;
```
在commonJS中，它会加载这个模块中所有的方法，生成一个大对象，然后找到你要使用的那个，**假如这个模块中有十个方法，
而你只需要使用其中一个，那么他也会把这十个加载出来**。

```js
// ES6模块
import { stat, exists, readFile } from 'fs';
```
而ES6中，使用哪个方法就是那个方法，即使这个模块中有多个，**也只是导出的是你要使用的那个，多余的不会导出**。

## 2. export 导出

使用`export`定义模块的导出、对外接口。

### 写法1

```js
// profile.js
export var firstName = 'Michael';
export var lastName = 'Jackson';
export var year = 1958;
```

### 写法2

```js
// profile.js
var firstName = 'Michael';
var lastName = 'Jackson';
var year = 1958;

export { firstName, lastName, year };
```

这样就能对外导出模块中的内容了

优先选择第二种方法，因为这样可以把所有的对外接口，写在一起，看起来容易。

除了可以导出**变量**，还可以**导出函数、类(class)**

### 注意点

需要记住的是`export`定义对外的接口，**必须和模块中的变量建立一一对应的关系，切记不能导出一个变量的值**。

```js
// 报错
export 1;

// 报错
var m = 1;
export m;
```
以上两种情况都是错误的，因为导出的是一个值，而并非是变量。

正确写法

```js
// 写法一
export var m = 1;

// 写法二
var m = 1;
export {m};

```

### 重命名

一般情况导出的名称就是模块内部声明的名称，假如还是想另外起一个名称则可以用关键字`as`

```js
function v1() { ... }
function v2() { ... }

export {
  v1 as streamV1,
  v2 as streamV2,
  v2 as streamLatestVersion
};
```
上面含义为将函数`v1`重命名为`streamV1`,然后再导出。也可以将同一个方法，重命名多次都是允许的。


