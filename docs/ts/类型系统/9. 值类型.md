ts规定，单个值也是一种类型，称为值类型。比如'hello'，则是一个字符串'hello'类型。

```typescript
let x:'hello';

x = 'hello'; // 正确
x = 'world'; // 报错

```

上面中，变量`x`的类型是字符串`hello`，导致它只能赋值为这个字符串，赋值为其他字符串就会报错。

## &#x20;ts推断

### &#x20;1. **`const`命令声明的变量不是对象时**

ts推断类型时，遇到**const命令声明的变量不是对象时**， **如果代码里面没有注明类型，就会推断该变量是值类型**。

```
// x 的类型是 "https"
const x = 'https';

// y 的类型是 string
const y:string = 'https';

```

上面示例中，变量`x`是`const`命令声明的，TypeScript 就会推断它的类型是值`https`，而不是`string`类型。

这样推断是合理的，因为`const`命令声明的变量，一旦声明就不能改变，相当于常量。值类型就意味着不能赋为其他值。

### &#x20;2. const声明的变量是对象时

则不会推断为值类型，而是根据属性来推断的。

```typescript
// x 的类型是 { foo: number }
const x = { foo: 1 }; // 推断属性foo的类型是number
```

### 3. 特殊点

当ts推断数值值类型时，会出现子类型和父类型。

比如下面这个代码，左侧会看作是数值5类型，而右侧**4+1**则会看作number类型，而数值5类型，是number的子类型，在ts中子类型可以赋值父类型，父类型不能赋值子类型，所以会报错。这里是两种类型。

```typescript
const x:5 = 4 + 1; // 报错
```

**子类型可以赋值给父类型，父类型不能赋值给子类型。**

假如说真想让父类型赋值为子类型，要用到\*\*类型断言。\*\*下面语句就是告诉编译器，4+1当做值类型来看待，而不是number类型。

```typescript
const x:5 = (4 + 1) as 5; // 正确
```

